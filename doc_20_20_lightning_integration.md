---
layout: default
title: Integration
parent: Lightning Network
has_children: false
nav_order: 2
---

# Integration
{: .no_toc }
The web application is reliant on the Lightning Node for different activities including:
- Generating new invoices
- Checking if an invoice has been paid
- Send out withdrawals to authors

The developers of LND created an API that allows the interaction with their deamon from a variety of programming languages either by **REST** or **gRPC**. [gRPC](https://grpc.io/faq/) is a modern, open source remote procedure call framework developed by Google and is based on HTTP/2. Compared to REST it does not use text based JSON messages but strongly typed stub messages. Those stubs are binary based and allow bidirectional streaming. Furthermore there is a performance gain of using gRPC.

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---
## gRPC
When using gRPC, a service is defined independent of any programming language in so called protocol buffers. These are file which define the services and messages that can be used. The `.proto` file used for LND can be [found on Github](https://github.com/lightningnetwork/lnd/blob/master/lnrpc/rpc.proto).

To use those services within our PHP application we first needed to create the gRPC code from the proto file. [This guide](https://grpc.io/docs/quickstart/php/) shows how to obtain the PHP code. In the folder `/src/Lnrpc/` of our project the generated code can be inspected.

Each interaction with the gRPC interface requires a client instance. `/src/rpcclient/RpcClient.php` creates such an instance with the following code.
```php
protected function __construct($node)
{
    putenv('GRPC_SSL_CIPHER_SUITES=HIGH+ECDSA');
    $nd = new NodeDAO();
    $node = $nd->readActive();
    $ssl = $node["fld_node_tls"];
    $macaroon = hex2bin($node["fld_node_macaroon"]);
    $lndIp = $node["fld_node_ip"];
    $metadataCallback = function ($metadata) use ($macaroon) {
        return ['macaroon' => [bin2hex($macaroon)]];
    };
    try{
        self::$clientInstance = new LightningClient($lndIp, [
            'credentials' => ChannelCredentials::createSsl($ssl),
            'update_metadata' => $metadataCallback
        ]);
    } catch (Exception $e) {
        throw new Exception($e->getMessage());
        echo "something went wrong";
    }

}
```
`Node-IP`, `SSL certificat` and a `macaroon` are required to connect to the node. All this information is stored in the database (`$nd->readActive()` returns an entry of the active node set in `tbl_node`).

`Node-IP`: IP address where the node can be reached. In our case it is localhost:10009 since we forward traffic via SSH to the remote Raspberry Pi.

`SSL certificat`: A certificate which is generated by the Lightning node and has to be stored in plain text to the database.

`macaroon`: A special authentication file which grants certain privileges to the owner of the file. More details follow in the next sub chapter.

[A full documentation of the API can be found here.](https://api.lightning.community/#lnd-grpc-api-reference)

## Authentication
LND has a special way to authenticate users to the node. Different files are being created on initial start up which grant the owner of the file different access rights. Per default there exist the following files:
- `admin.macaroon`: Grants full read and write access to all gRPC commands. This is used by the lncli client.

- `readonly.macaroon`: Grants read-only access to all gRPC commands. Could be given to a monitoring application for example.

- `invoice.macaroon`: Grants read and write access to all invoice related gRPC commands (like generating an address or adding an invoice). Can be used for a web shop application for example. Paying an invoice is not possible, even if the name might suggest it. The permission offchain is needed to pay an invoice which is currently only granted in the admin macaroon.

(source [https://github.com/lightningnetwork/lnd/tree/master/macaroons](https://github.com/lightningnetwork/lnd/tree/master/macaroons))

Unfortunately, no option of the above is suited for our use case. Both `readonly.macaroon` and `invoice.macaroon` have not enough permission to make a lightning payment which is required to payout withdrawals to authors. Of course the `admin.macaroon` file could be used and stored on the web server. However this would give complete control over the whole node to whoever has access to the file. This would severely violate the **rule of least privileges**.

Since version x LND allows to create macaroon files with custom permissions. This so called macaroon bakery is described in more detail [on LND's Github page](https://github.com/lightningnetwork/lnd/blob/master/macaroons/README.md#bakery).

We used the following command to create our own macaroon file:
```
lncli bakemacaroon onchain:read offchain:read offchain:write info:read invoices:read invoices:write peers:read message:read address:read  --save_to=/path/to/webapp.macaroon
```
It gives **read** permissions to `onchain transactions`, `node information`, `peer information`, `messages` and `addresses` but **write** permissions to `invoices` and `offchain transactions`. This is exactly enough permissions to create invoices and pay offchain to other invoices (used for withdrawals).

The content of the newly created macaroon file is stored in hexadecimal in the column `fld_node_macaroon` of the database table `tbl_node`. To obtain the hexadecimal representation, the following code can be executed once:
```
$f = file_get_contents('/path/to/webapp.macaroon');
var_dump(bin2hex($f));
```

## Invoice generation
Whenever a payment is executed by a visitor of the website, either to read an article or to make a donation, a new unique invoices is created by the lightning node. The following code snippet is explained in more detail:

```
public function createPayment(Payment $payment) : Payment
{
    $client = RpcClient::connect();
    $ln_inv = new Invoice();
    $ln_inv->setMemo($payment->getMemo());
    $ln_inv->setValue($payment->getValue());
    list($reply, $status) = $client->AddInvoice($ln_inv)->wait();

    // set payment request from AddInvoice Response
    $payment->setPayReq($reply->getPaymentRequest());
    $rhash_hex = bin2hex($reply->getRHash());
    // set payment hash from AddInvoice Response
    $payment->setRhash($rhash_hex);

    // get additional information from generated invoice
    $payment = $this->getUpdateFromNode($payment);

    $pay_dao = new PaymentDAO();
    $payment = $pay_dao->create($payment);
    return $payment;
}
```
The function `createPayment` takes a `domain\Payment` object in order to create an invoice on the lightning node and stores the object to the database.

1. An instance of the RpcClient is obtained to communicate with the lightning node.
2. A new empty `Lnrpc\Invoice` object is being created (`$ln_inv`)
3. Populate **memo** field of `$ln_inv` (copied from `$payment`)
4. Populate **value** field of `$ln_inv` (copied from `$payment`)
5. Invoke the `AddInvoice` function of the RpcClient and pass the `Lnrpc\Invoice` object. The result will be stored in the variable `$reply`.
6. Store the payment request from the `$reply` to the `$payment`.
7. Store the payment hash from the `$reply` to the `$payment`.
8. Store the payment to the database
9. Return the `domain\Payment` object

## Withdrawal
Content producers who publish and earn on the platform can gain control over their funds by withdrawing their balance to an external wallet. Since lightning payments are always bound to an invoice  that is created by the receiver, the user must first create an invoice in the wallet and provide it to the website to issue the payment.

### via pasting an invoice
This is the easiest way to issue a withdrawal payment. The user inputs an invoice into the text field and the payment is executed via the lightning node. The invoice contains all information in a special encoding.

The `validator\WithdrawalValidator` checks if the invoice can be decoded and the user has enough funds.

Then a `domain\Withdrawal` object is being created and populated with the information from the decoded invoice (`InvoiceServiceImpl->decodePayReq`).

Eventually, the payment is sent out in the `InvoiceServiceImpl->payOut` function.
### via LNURL
Often the user has its wallet on a different device (e.g. smartphone) than he or she is using for visiting the lightread platform (e.g. desktop). This makes the process of copy/paste a very long invoice (e.g. lnbc10u1p0p7vd4pp5kv64pwe4flefwsp2c4ztackg2w9l9ldwqg7gcdl2chpl0xhycvesdr8g3hkuct5d9hkugr0dcsxzun5d93kcef6yqn5zmneypfxzmnydakjq4rfw3kx2feqvfujqctwypskummw09kk7atnyp6hxetjyqaz62gcqzpgfs7fugnugxlunjdgmncra339x99r8a27evmjg3tgacuvt7t3a998te8sm5glmypy4zqq0wjr0xvkgadyktrkstntp2e8cw6xa7r759cqudz65f) very tedious. The **LNURL** protocol ([see specification](https://github.com/btcontract/lnurl-rfc/blob/master/spec.md#3-lnurl-withdraw)) provides a solution that simplifies the user experience of providing a invoice from a mobile wallet.

#### LNURL quickly explained
The goal of the protocol is to allow a end user to withdraw money from a desktop website to a mobile wallet. Instead of creating an invoice on a mobile and copy it to the website, the process is started by scanning a QR code from the website. Then the following steps are followed:

**Wallet to service interaction flow:**

`LN WALLET` is the users mobile Lightning wallet.

`LN SERVICE` is the lightread webapp.

1. User scans a LNURL QR code or accesses an `lightning:LNURL..` link with `LN WALLET` and `LN WALLET` decodes LNURL.
2. `LN WALLET` makes an HTTPS GET request to `LN SERVICE` using the decoded LNURL. This GET request is handled by the following route:
```
$router->get('/lnurl/info_request', function () {
    WithdrawalController::lnUrlInfoRequest();
});
```
3. `LN WALLET` gets Json response from `LN SERVICE` of form:

	```
	{
		callback: String, // the URL which LN SERVICE would accept a withdrawal Lightning invoice as query parameter
		k1: String, // random or non-random string to identify the user's LN WALLET when using the callback URL
		maxWithdrawable: MilliSatoshi, // max withdrawable amount for a given user on LN SERVICE
		defaultDescription: String, // A default withdrawal invoice description
		minWithdrawable: MilliSatoshi // An optional field, defaults to 1 MilliSatoshi if not present, can not be less than 1 or more than `maxWithdrawable`
		tag: "withdrawRequest" // type of LNURL
	}

  // implementation in /src/WithdrawalController.php line 103 and following
  $prc->callback = $GLOBALS["ROOT_URL"] . '/lnurl/withdraw';//string to send invoice to;
  $prc->k1 = $secret;
  $prc->maxWithdrawable = ($existing->getValue() *1000);//in msat
  $prc->defaultDescription = $existing->getMemo();
  $prc->minWithdrawable = 0;//in msat
  $prc->tag = "withdrawRequest";
  $myJSON = json_encode($prc);
  echo $myJSON;
  exit;
	```
	or

	```
	{"status":"ERROR", "reason":"error details..."}
	```
4. `LN WALLET` Displays a withdraw dialog where user can specify an exact sum to be withdrawn which would be bounded by:

	```
	max can receive = min(maxWithdrawable, local estimation of how much can be routed into wallet)
	min can receive = max(minWithdrawable, local minimal value allowed by wallet)
	```
5. Once accepted by the user, `LN WALLET` sends an HTTPS GET to `LN SERVICE` in the form of

	```
	<callback>?k1=<k1>&pr=<lightning invoice, ...>
	```

	Note that user may send multiple invoices with a splitted total amount in a single request.

  Handled by the following route:
  ```
  $router->get('/lnurl/withdraw', function () {
      WithdrawalController::lnUrlPaymentRequest();
  });
  ```
6. `LN SERVICE` sends a `{"status":"OK"}` or `{"status":"ERROR", "reason":"error details..."}` Json response.
7. `LN WALLET` awaits for incoming payment if response was successful.

Note that service will withdraw funds to anyone who can provide a valid ephemeral `k1`. In order to harden this a service may require autorization (LNURL-auth, email link etc.) before displaying a withdraw QR.


(source [https://github.com/btcontract/lnurl-rfc/blob/master/spec.md](https://github.com/btcontract/lnurl-rfc/blob/master/spec.md))

In order to use the LNURL withdrawal scheme it is required to use a compatible wallet. [Please check this page to find compatible wallets.](https://tkone7.github.io/lightread/doc_20_30_lightning_wallet.html)
